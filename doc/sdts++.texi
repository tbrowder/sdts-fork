\input texinfo		@c -*- texinfo -*-
@c
@c $Id: sdts++.texi,v 1.21 2003/06/10 18:15:51 mcoletti Exp $
@c $Revision: 1.21 $
@c
@c %** Start of header
@setfilename sdts++.info
@settitle @code{sdts++} Library
@setchapternewpage odd

@c Put functions in the concept index
@syncodeindex fn cp

@c Create an index of types
@defindex ty
@c Put the types in the concept index
@syncodeindex ty cp

@c The following three conditionals allow us to emulate the nonexistent
@c `@else' directive.
@iftex
@set tex
@end iftex

@ifinfo
@set info
@end ifinfo

@ifhtml
@set html
@end ifhtml

@tex
% Set the manual edition number to the RCS revision number, and have it
% be automatically generated, just to keep things simple.
% This is rather kludgy, actually: argument #1 is the colon from the RCS
% string. It's only there so that RCS/CVS won't expand the wrong thing.
@xdef@seteditionone$Revision#1 #2 ${#2}
@xdef@edition{@seteditionone$Revision: 1.21 $}
@end tex
@c %** End of header


@ifinfo
This document describes what the SDTS++ toolkit is and how to use it.

Copyright @copyright{} 2001 United States Geological Survey.

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.
@end ifinfo

@titlepage
@title The @code{sdts++} Library
@subtitle A C++ Toolkit for Reading and Writing SDTS Modules
@iftex
@subtitle Edition @edition
@end iftex
@author Mark Coletti <mcoletti@clark.net>

@page
@vskip 0pt plus 1filll
Copyright @copyright 2003 United States Geological Survey.

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.
@end titlepage

@node Top, Introduction, (dir), (dir)
@comment  node-name,  next,  previous,  up

@ifinfo
@cindex SDTS
Programmers can use sdts++ classes to read and write Spatial Data
Transfer Standard (SDTS) files.
@end ifinfo

@menu
* Introduction::                About SDTS++
* Installing::                  How to build and install sdts++
* Using::                       How to use sdts++
* Credits::                     The guilty parties
* Legalese::                    Text for those with JDs
* Support::                     Where to go to get sdts++ related help
* Bibliography::                Some recommended reading

* Concept Index::               
@end menu

@c ===========================================================================

@node Introduction, Installing, Top, Top
@comment  node-name,  next,  previous,  up
@chapter Introduction

@cindex Introduction

SDTS++ is a C++ toolkit for reading and writing SDTS datasets.
Application developers can use SDTS++ library classes to work with the
logical structure of these datasets without having to worry about the
physical details of each dataset.

@cindex STL
@cindex Standard Template Library
Please note that this document assumes that you are not only familiar
with C++, but with the Standard C++ Library; and, more importantly,
you are knowledgeable with using the Standard Template Library (STL).


@c ===========================================================================
@node Installing, Using, Introduction, Top
@comment  node-name,  next,  previous,  up
@chapter Installing

@cindex UNIX
@cindex Visual C++
@cindex Installing
@cindex Building

Here we describe how to build and install sdts++ for both UNIX and Windows.

@menu
* Windows::                     Installing for Windows using Visual C++
* UNIX::                        Installing for UNIX and UNIX-like systems
@end menu


@node Windows, UNIX, Installing, Installing
@comment  node-name,  next,  previous,  up
@section Installing for Windows

So far, the only Windows compilers that have been exercised on
@code{sdts++} have been Visual C++ 6.0 and cygwin's gcc.  Building for
the latter compiler is easy; just follow the UNIX build section
instructions.

@enumerate
@item
Create or open a workspace

@item
Add the VC++ project file ``Windows/sdtsxx/sdtsxx.dsp'' to the workspace

@item
Build the project

@item
You're done!

@end enumerate

Alternatively, you can use the Boost bjam build utility.

@enumerate
@item edit @file{Jamrules} and @file{boost-build.jam} to reflect
location of Boost.  The Boost C++ library can be fetched from
@url{http://www.boost.org/}

@item install the bjam executable somewhere in your $PATH.  It can be
gotten from @url{http://www.boost.org/tools/build/index.html#Jam}.

@item @code{cd sdts++; bjam -sTOOLS=msvc}

@item @code{cd ../sysutils; bjam -sTOOLS=msvc}

@end enumerate

Debug and release binaries for the sdts++ and dependant sysutils
libraries will be in the @file{sdts++/bin} and @file{sysutils/bin}
directory hierarchies, respectively.  Build behavior can be modified
by editing the @file{Jamfile}s located in @file{sdts++} and
@file{sysutil}.  There also exists a @file{Jamfile} for the test
harnasses found in @file{tests}.

Note that compilers are specified via @var{TOOLS} and support not just
Microsoft Visual C++ and GNU g++.  Please see the Boost web site for a
canonical list of supported compilers. 



@node UNIX,  , Windows, Installing
@comment  node-name,  next,  previous,  up
@section Installing for UNIX

@enumerate
@item
Run the configure script.

Please note that the configure script will try and use the GNU
C/C++ compiler if it finds it.  You can over-ride the configure script
by specifying the C and/or C++ compilers by setting the CC and CXX
environment variables, respectively.  For example, to prefer to use
@kbd{/usr/bin/CC} as the C++ compiler, invoke the script like this:

        @kbd{% env CXX=/usr/bin/CC ./configure}


@item
Run make to build the library

Note that you will need to use GNU make.  It can be fetched via
anonymous ftp from @url{http://www.gnu.org/software/make}.


@item
Optionally, run `make check' to build and run test programs

@item
@kbd{make install} to copy the header and library files to the target
directories.

@end enumerate

By default, these directories will be @file{/usr/local/include/sdts++}
for the header files and @file{/usr/local/lib/} for the library.  You
can change these target directories by using the parameter
@kbd{--prefix=/my/target/dir} when invoking the configure script.  If
you just want the @emph{binaries} to go to a different place (and thus
have the headers go to a default location), then you can specify
@kbd{--exec-prefix=/my/target/binary/dir} instead.

Note that you can also use bjam to build the library on most UNIX
platforms.  Simply follow the instructions found in the previous
section using, say, ``-sTOOLS=gcc'' to specify the GNU g++ compiler.
Again, please consult the Boost bjam documentation for more information.





@c ===========================================================================
@node Using, Credits, Installing, Top
@comment  node-name,  next,  previous,  up
@chapter Using

@cindex Library Organization
The SDTS++ library is comprised of four major components, or
"sub-systems".  These are the Container, I/O, Builder, and Logical
sub-systems.  The Container subsystem is used to hold SDTS data.  The
I/O sub-system, naturally, is responsible for reading and writing SDTS
data -- it relies on Container objects to hold data that is either
read in or to be written out.  The Builder contains convenience
classes for translating SDTS data at a higher level than provided by
raw Container classes.  Similarly, the Logical classes contain
convenience classes for some SDTS spatial types.  The next sections
will discuss each sub-system in turn.



@c ===========================================================================
@menu
* Container Classes::           About modules, records, fields, and subfields
* I/O Classes::                 How to read and write sdts++ containers
* Builder Classes::             Convenience classes to read and write modules
* Logical Classes::             Experimental classes for holding spatial data
@end menu

@node Container Classes, I/O Classes, Using, Using
@comment  node-name,  next,  previous,  up
@section Container Classes

The SDTS transfer model contains several logical constructs for
holding data.  They are: modules, which contain records, which contain
fields, which contain subfields.  SDTS++ provides classes that
correspond to these logical constructs.  The table below depicts these
classes and their respective relationships to the SDTS transfer model.


@example
        SDTS            SDTS++

        Module          sc_Module
        Record          sc_Record
        Field           sc_Field
        Subfield        sc_Subfield
@end example



@menu
* Container interface::         Detailed descriptions for all the containers
@end menu



@node Container interface,  , Container Classes, Container Classes
@comment  node-name,  next,  previous,  up
@subsection Container interface
        
All SDTS++ containers (i.e., sc_Module, sc_Record, and sc_Field) have
the following member functions, which are provided by STL (since they
are implemented as STL containers) @cite{Musser & Saini 1996}:

@ftable @code

@item X()
default constructor

@item X(a)
constructor

@item X u(a)
copy constructor

@item ~X()
destructor

@item a.begin()       
returns an iterator, or const iterator if a is constant

@item a.end()         
returns an iterator that points just one element beyond the last element

@item a.rbegin()      
returns a reverse iterator

@item a.rend()        
returns a reverse iterator that points to just one element before the first

@item a.size()        
returns number of elements

@item a.max_size()    
largest possible size()

@item a.empty()       
returns true if there are no elements

@item r = a           
assigns contents of a to r

@item a.swap(b)       
swap the two container contents

@end ftable


There are other member functions provided by the STL list
implementation that we used for the SDTS++ containers.  Please consult
an STL resource for more information on how to use STL containers.



@menu
* sc_Module::                   SDTS module container
* sc_Record::                   SDTS record container
* sc_Field::                    SDTS field container
* sc_Subfield::                 SDTS subfield container
@end menu


@node sc_Module, sc_Record, Container interface, Container interface
@comment  node-name,  next,  previous,  up
@subsubsection sc_Module


This class is analagous to an SDTS module.  Like an SDTS module, it
contains zero or more records.



@node sc_Record, sc_Field, sc_Module, Container interface
@comment  node-name,  next,  previous,  up
@subsubsection sc_Record

This class is equivalent to an SDTS record and is composed of sc_Field
objects.



@node sc_Field, sc_Subfield, sc_Record, Container interface
@comment  node-name,  next,  previous,  up
@subsubsection sc_Field

This class corresponds to a SDTS field and is composed of sc_Subfield
objects.  In addition to the inherited STL member functions, some
additional functions have been added to allow an application to read
or change the field name and field mnemonic.  The following describes
these additional functions:
                                                       
@ftable @code
@item string const& getName() const  
Returns the SDTS name of the field.  (if one has been set)

@item string const& getMnemonic() const  
Returns the SDTS mnemonic of the field.  (if one has been set)
 
@item string const& setName() const
Returns the string parameter passed to the function and sets the
sc_field name to that value.  string const& setName() const

@item string const& setMnemonic() const
Returns the string parameter passed to the function and sets
the sc_field mnemonic to that value.

@end ftable



@node sc_Subfield,  , sc_Field, Container interface
@comment  node-name,  next,  previous,  up
@subsubsection sc_Subfield

This is the atomic class within the container sub-systems -- it is the
only non-container and is itself not comprised of any other classes.
An sc_Subfield contains the value of a SDTS subfield.

sc_Subfields defines the enumerator SubfieldType.  The following table
delineates these values and their corresponding meanings:

@vtable @code
@item is_A       
graphic, alphanumeric, or alphabetic characters.

@item        is_I       
implicit-point (integer)

@item        is_R       
explicit-point unscaled (fixed point, real)

@item        is_S       
explicit-point scaled (floating point, real)

@item        is_C       
character mode bitfield (binary in zero and one characters)

@item        is_B       
bitfield data

@item      is_BI8       
8 bit signed integer

@item     is_BI16       
16 bit signed integer

@item     is_BI24       
24 bit signed integer

@item     is_BI32       
32 bit signed integer

@item      is_BUI       
unsigned integer, length specified by implementation

@item     is_BUI8       
8 bit unsigned integer

@item    is_BUI16       
16 bit unsigned integer

@item    is_BUI24       
24 bit unsigned integer

@item    is_BUI32       
32 bit unsigned integer

@item    is_BFP32       
32 bit floating point real

@item    is_BFP64       
64 bit floating point real

@end vtable


The mapping from SDTS types to C++ is as follows:
   
@table @code
@item        A                               
string

@item        I                               
long

@item        R,S                             
double

@item        C                               
not implemented

@item        BUI                             
unsigned long

@item        BI8, BI16, BI24, BI32           
long

@item        BUI8, BUI16, BUI24, BUI32       
unsigned long

@item        BFP32, BFP64                    
double

@end table
     

The sc_Subfield class has the following members:

@ftable @code

@item    sc_Subfield( )   

@item    sc_Subfield( sc_Subfield const& right) 

@item    ~sc_Subfield()  

@item     sc_Subfield& operator=(sc_Subfield const& right)

@item     bool operator==(sc_Subfield const& right) const

        This returns true if both subfields have the same name,
        mnemonic, type, and value.

@item     bool operator!=(sc_Subfield const& right) const 

        inverse of operator==()

@item     SubfieldType getSubfieldType() const

        Returns the subfield data type of the data in the sc_Subfield
        object.  The return value of SubfieldType is an enumerated
        data type that describes the type as one of the types listed
        above.

@item     string const& getName() const

        Returns the SDTS name of the subfield.

@item     string const& getMnemonic() const

        Returns the SDTS mnemonic of the subfield.

@item     string const& setName(string const& name)

        sets the sc_subfield name to the given string and returns it

@item     string const& setMnemonic(string const& mnem)

        sets the sc_subfield mnemnonic to the given string and returns it

@end ftable

These functions are used to fetch a subfield's value; there is one
function for each of the canonical subfield types.  Each will return
'false' if the subfield contains an incompatible value.  For example, if
the subfield is a string (i.e., @code{is_A}) and its @code{getBI32()}
function is invoked, then that call will fail.

@ftable @code
@item     bool getA(string& val) const
@item     bool getI(long& val) const
@item     bool getR(double& val) const
@item     bool getS(double& val) const
@item     bool getC(string& val) const
@item     bool getBI8(long& val) const
@item     bool getBI16(long& val) const
@item     bool getBI24(long& val) const
@item     bool getBI32(long& val) const
@item     bool getBUI8(unsigned long& val) const
@item     bool getBUI16(unsigned long& val) const
@item     bool getBUI24(unsigned long& val) const
@item     bool getBUI32(unsigned long& val) const
@item     bool getFP32(double& val) const
@item     bool getFP64(double& val) const
@end ftable

Naturally each of the previous functions has a corresponding inverse
to set a value for a given type.  Note that after a particular set
function is used, the subfield's type is set to that.  E.g., invoking
@samp{setI()} will set that subfield's type to @samp{is_I}.

@ftable @code
@item     void setA(string const& val)
@item     void setI(long val)
@item     void setR(double val)
@item     void setS(double val)
@item     void setC(string const& val)
@item     void setBI8(long val)
@item     void setBI16(long val)
@item     void setBI24(long val)
@item     void setBI32(long val)
@item     void setBUI8(unsigned long val)
@item     void setBUI16(unsigned long val)
@item     void setBUI24(unsigned long val)
@item     void setBUI32(unsigned long val)
@item     void setFP32(double val)
@item     void setFP64(double val)
@end ftable




@c ===========================================================================
@node I/O Classes, Builder Classes, Container Classes, Using
@comment  node-name,  next,  previous,  up
@section I/O Classes

The I/O subsystem is responsible for reading and writing SDTS
transfers.  The I/O subsystem has two major parts: readers and
writers.  Readers are used to read in SDTS data and store them into
SDTS++ container objects.  Writers are the inverse of readers; they
take data found in SDTS++ container objects and write them out to SDTS
transfers.  We'll discuss readers and writers in the following sections.



@menu
* Readers::                     Used to read SDTS data into containers
* Writers::                     Used to write SDTS modules from containers
@end menu



@node Readers, Writers, I/O Classes, I/O Classes
@comment  node-name,  next,  previous,  up
@subsection Readers

There are two vital components to reading SDTS data in SDTS++: readers
and reader iterators.  Readers are attached to a input file stream
that is open onto a valid SDTS 8211 module file.  Then one or more
reader iterators are then, in turn, attached to that reader.  The user
then uses these iterators to fetch records in a given sc_Record
object, move to the next record, and to determine when there are no
more records to be read.  

Readers are passive entites from a user's perspective; all the real
work is done via iterators.  The user interacts with a reader through
one of its iterators and never directly through a reader.  The
iterator works with its reader behind the scene to fetch records, move
forward to the next record, and to report that there are no more records.


@menu
* Reader and Reader Iterator Base Classes::  
* sio_Reader::                  
* sio_ForwardIterator::         
* sio_8211Reader::              
* 8211 Forward Iterator::       
* Reader Example::              
@end menu



@node Reader and Reader Iterator Base Classes, sio_Reader, Readers, Readers
@comment  node-name,  next,  previous,  up
@subsubsection Reader and Reader Iterator Base Classes

We recognized early on in SDTS++'s design process that there might
conceivably exist alternative physical forms for an SDTS dataset.  To
this end, we designed abstract base classes for a "generalized" reader
and reader iterator.  These are, respectively, sc_Reader and
sc_ForwardIterator.




@node sio_Reader, sio_ForwardIterator, Reader and Reader Iterator Base Classes, Readers
@comment  node-name,  next,  previous,  up
@subsubsection  sio_Reader

sio_Reader declares the following interface:

@ftable @code
@item     sio_Reader( istream & is )

            Initializes the reader for the given stream.  (Note that
            the current implementation differs from this.  It has a
            second parameter that takes a pointer to a converter
            container.  This is wrong and will be changed in a
            subsequent implementation.)

@item     virtual ~sio_Reader() = 0;
@end ftable



        
@node sio_ForwardIterator, sio_8211Reader, sio_Reader, Readers
@comment  node-name,  next,  previous,  up
@subsubsection sio_ForwardIterator

Again, the sio_ForwardIterator provides the means of navigating through
SDTS records, to retrieve record contents, and to report that there
are no more records in the corresponding reader's associated SDTS
module.  As its name suggests, it is only possible to move forward
from record to record.  Iterating "backwards" or random record access
are not supported by this class.

sio_ForwardIterator declares the following interface:

@ftable @code
@item     virtual ~sio_ForwardIterator( )

@item     virtual bool get( sc_Record& record )  = 0;

        Returns true if get successful, else false.  If successful,
        the given record will be filled with the corresponding
        contents of the current SDTS module record.

@item     virtual void operator++() = 0;

        Moves the iterator forward to the next SDTS record.

@item     virtual bool done() const = 0;

        Returns non-zero if no more data or reader is in error state.

@item     virtual operator void*() const = 0;

        Returns a non-null void * if there's still more data to read.

@end ftable




@node sio_8211Reader, 8211 Forward Iterator, sio_ForwardIterator, Readers
@comment  node-name,  next,  previous,  up
@subsubsection sio_8211Reader

@code{sio_8211Reader}, as dictated by its parent @code{sio_Reader},
manages the reading of SDTS records from an input stream.  However,
there is one issue that it has to address that is peculiar to ISO 8211
and to SDTS.  That is, @code{sio_8211Reader} needs some help to properly
translate binary SDTS data.

The problem is that ISO 8211 can only describe a binary subfield by
its width in bits.  For example a valid ISO 8211 binary description
would be @samp{B(32)}, which means a subfield that is binary and has 32
bits.  Fair enough, but what exactly do those bits represent?  A 32
bit signed integer?  Unsigned?  Is it a 32 bit floating point field?

SDTS should have descriptions for exactly how to translate these
binary values.  Where these descriptions are depend on the binary
value in question.  For example, spatial data binary types are
described in the IREF module.  Here's a sample dump from an IREF
module:

@example
IREF : INTERNAL SPATIAL REFERENCE
        MODN : IREF
        RCID : 1
        SATP : 2-TUPLE
        XLBL : EASTING
        YLBL : NORTHING
        HFMT : BI32
        SFAX : 0.01
        SFAY : 0.01
        XORG : 0
        YORG : 0
        XHRS : 2.54
        YHRS : 2.54
@end example

The @samp{HFMT} subfield describes the spatial data format for SDTS
modules.  Here you can see that spatial data are represented as
@samp{BI32}.

There exist a set of classes that we call "converters" that are
responsible for translating data between raw 8211 and SDTS subfields.
Normally they'd be a hidden implementation detail.  Unfortunately
we've had to expose this detail a bit to work around this problem of
properly translating binary data.

The second @code{sio_8211Reader} constructor argument is optional.  You
may provide it a map of SDTS subfield mnemonics to converters as a
"hint" to the reader for any binary data it might encounter.  If the
reader runs across a binary field, it will search the converter map you
gave it for the mnemonic for that binary field; it will use the
converter you specify if it finds a match.  If it can't find a match,
then the read will fail.

So, to continue from the preceding example, we'd set up a reader for
spatial data given that we want to use a BI32 converter this way:

@example
@code{
        // see "sdts++/io/sio_ConverterFactory.h" for convenient converter builder
        converter_dictionary converters;


        // ask the canonical instance of the converter factor to return
        // a pointer to an sio_8211Converter_BI32 object

        converters["X"] = sio_ConverterFactory::instance()->get( "BI32" );
        converters["Y"] = sio_ConverterFactory::instance()->get( "BI32" );
        
        sio_8211Reader  reader( my_ddf_stream, &converters );
}
@end example

So if "reader" happens across a binary subfield with either the
subfield mnemonics of "X" or "Y", it will use our @code{BI32} converter,
@samp{bi32_converter}.



sio_8211Reader declares the following public members:

@ftable @code
@item     sio_8211Reader( istream & is,  const map<string, sio_8211Converter*> * converters = 0)

        Constructor taking arguments for input stream containing a
        valid SDTS module, and optionally a pointer to binary
        converter hints.

@item     ~sio_8211Reader()

@item     sio_8211Schema & getSchema()

        Returns the schema that the reader built from the module's
        DDR.  (This is a test member function that allowed us to read
        existing SDTS modules and write them again using SDTS++.
        Please see the section on sio_Writer for more information on
        schemas.)

@end ftable




@node 8211 Forward Iterator, Reader Example, sio_8211Reader, Readers
@comment  node-name,  next,  previous,  up
@subsubsection 8211 Forward Iterator


sio_8211ForwardIterator declares the following public members:

@ftable @code

@item     sio_8211ForwardIterator( sio_8211Reader& reader )

        Constructor that attaches the iterator to the given reader.

@item     bool get( sc_Record& record )

        Fills the given record with the contents of the current SDTS
        record.  Returns false if there were problems reading that
        record.

@item     void operator++()

        Move on to the next SDTS record.

@item     bool done() const

        Returns true if there are no more records.

@item     virtual operator void*() const

        Is non-zero if there are still records to read and if there
        aren't any problems with the reader.

@end ftable




@node Reader Example,  , 8211 Forward Iterator, Readers
@comment  node-name,  next,  previous,  up
@subsubsection Example

Please see @file{contrib/prsdts/prsdts.cpp} for sample
code used to read an SDTS module.



@node Writers,  , Readers, I/O Classes
@comment  node-name,  next,  previous,  up
@subsection Writers

@cindex Writers
@cindex Creating Modules
Writers are the mechanisms for creating SDTS modules.  They operate by
writing the contents of a given container of SDTS data in a specific
physical format.  Different writers will support different formats.
Currently the only available writer emits proper ISO 8211 based SDTS
modules.


@menu
* sio_Writer::                  
* sio_8211Writer::              
* Schemas::                     
* sio_8211FieldFormat::         
* sio_8211SubfieldFormat::      
* Repeating fields::            
* A note about repeating binary fields::  
* Support for permuted tags::   
* Dropped leaders and directories::  
* Writer Example::              
@end menu


@node sio_Writer, sio_8211Writer, Writers, Writers
@comment  node-name,  next,  previous,  up
@subsubsection sio_Writer


Like the reader, @code{sio_Writer} is an abstract base class.  It is
intended to be a parent for any writers that emit SDTS modules in the
physical format of choice -- whether that be ISO 8211 or some other
physical representation.

(Please note that ISO 8211 is the only official physical format.
However, one could develop a writer that writes in some sort of plain
ASCII format, Hierarchical Data Format (HDF), etc.  In other words,
use the sio_Writer interface to provide some form of translator from
SDTS to another format.)

@code{sio_Writer}, unlike @code{sio_Reader}, does not have a
corresponding iterator.  Since a reader doesn't itself modify a module's
data, it's safe to have multiple iterators attached to it.  However, we
felt that the complexity inherent in keeping track of different
iterators for a given writer didn't buy us much.  Not only would we have
to implement some form of record locking, but we also recognized that
the majority of the time the writer would be used in a straightforward
sequential fashion.  That is, by the time a writer is brought into play,
the user typically would want to write out all the data in a single
straight shot.

Instead of using an iterator, the user will interact directly with a
writer.  The user will hand a writer an @code{sc_Record}, which it will
emit in the proper physical format to a corresponding output stream.
Subsequent records given to the writer will simply be concatenated to
any previous records.

sio_Writer declares the following interface:

@ftable @code

@item     virtual ~sio_Writer() = 0

@item     virtual bool put( sc_Record& ) = 0

        Will write the given record out to the stream.

@item     virtual bool good( ) const = 0

        Returns true if the writer is in a usable state.

@end ftable




@node sio_8211Writer, Schemas, sio_Writer, Writers
@comment  node-name,  next,  previous,  up
@subsubsection sio_8211Writer

@code{sio_8211Writer} is, as you might guess, a writer for emitting
proper 8211 encodings of SDTS data.  And, as with @code{sio_8211Reader},
there are issues peculiar to 8211 that this class has to cope with.

That is, we want to write out a complete DDR before writing any DR's.
At one time we thought of a design that would modify the DDR as each
DR was written out -- any new fields that weren't already in the DDR
would be added on the fly.  We felt that not only would this exact a
terrible toll on performance, but it would add greatly to this class'
complexity.  So we decided to pay the price up front and write out a
complete DDR before writing any DRs.

The problem here is that the user has to give enough information to the
@code{sio_8211Writer} ahead of time for it to write out a proper DDR.
The mechanism for this is called a 'schema'.  This is a data structure
that contains all the field and subfield information that an
@code{sio_8211Writer} will need to not only write out that DDR, but to also
properly write out data for each DR.  We discuss schemas in more detail
later.

sio_8211Writer has the following public interface:

@ftable @code

@item  sio_8211Writer( ofstream & ofs, const char* title, sio_8211Schema const & schema )

@item sio_8211Writer( ofstream & ofs, const char* title )

        Constructors that take arguments to an open file stream where
        the 8211 data will be written, a title to be used in the 8211 file
        identifier field, and a schema describing the field and subfield
        structures and the appropriate subfield converters.


@item  ~sio_8211Writer()


@item  void setFileTitle( const char* fn )

        Used to set the ISO 8211 file title field.


@item  void setSchema( sio_8211Schema const & schema )

        Used to set the schema for the writer.


@item  bool emitDDR()
  
        Writes the DDR to the ``ofs'' given in the constructor.
        Returns false if something went wrong.


@item  bool put( sc_Record& record )

        Writes the contents of the given record to the ``ofs'' given
        to the constructor.  Returns false if something went wrong.


@item  bool good( ) const;
  
        Returns true if the writer can write a record and if the last
        operation worked ok.


@item  void reuseLeaderAndDirectory()

The next @code{put()} will emit a special leader and a directory.  All
subsequent @code{put()} invocations will emit only field data areas --
the last leader and directory will be 're-used' to save space. (C.f.,
ISO/IEC 8211:1994(E), page 44, C.1.5.2, "repeating leaders and
directories").

@emph{PLEASE NOTE THAT THIS ASSUMES THAT ALL SUBSEQUENT RECORDS HAVE
IDENTICAL RECORD LENGTHS AND FORMATS.}  The behavior of @code{put()} is
undefined for records that do not match the format found in the last
leader and directory.

@end ftable




@node Schemas, sio_8211FieldFormat, sio_8211Writer, Writers
@comment  node-name,  next,  previous,  up
@subsubsection Schemas

A schema, which is formally known in SDTS++ as sio_8211Schema, is an STL
container of @code{sio_8211FieldFormats}.  An @code{sio_8211FieldFormat}
contains information about an 8211 field.  It is also a container of
@code{sio_8211SubfieldFormats} -- @code{sio_8211Subfield}s describe,
naturally, 8211 subfields.  We will describe each of these in turn.




@node sio_8211FieldFormat, sio_8211SubfieldFormat, Schemas, Writers
@comment  node-name,  next,  previous,  up
@subsubsection sio_8211FieldFormat

This class corresponds to an ISO 8211 DDR field format description.

@code{sio_8211FieldFormat} defines the following enumerators:

@example
@code{
        typedef enum @{ elementary, 
                       vector, 
                       array, 
                       concatenated @} data_struct_code;

        typedef enum @{ char_string, 
                       implicit_point, 
                       explicit_point, 
                       explicit_point_scaled, 
                       char_bit_string, 
                       bit_string, 
                       mixed_data_type @} data_type_code;
}
@end example

sio_8211FieldFormat declares the following public members:


@ftable @code


@item    sio_8211FieldFormat()

@item     sio_8211FieldFormat( sio_8211FieldFormat const & )

@item     ~sio_8211FieldFormat()

@item     sio_8211FieldFormat& operator=( sio_8211FieldFormat const & )

@item     data_struct_code getDataStructCode( ) const

        Returns the data structure code; that is, whether it's an
        elementary, vector, array, or concatenated field.

@item     data_type_code getDataTypeCode( ) const

        Returns the data type code; that is, whether it's a character
        string, integer, real, character bit string, a raw binary
        type, or it's a complex field comprised of subfields of mixed
        types.

@item     string const& getTag( ) const

        Returns the field tag.


@item     string const&     getName( ) const

        Returns the field name.


@item     char getFieldTerm( ) const

        Returns the visible field terminator character.


@item     char getUnitTerm( ) const

        Returns the visible unit terminator character.


@item     bool isRepeating() const

        This indicates that this field has multiple instances in
        single record.  Although this is usually automatically handled
        by the writer, we need to tell the writer this explicitly in
        the case of binary repeating fields so that the proper set of
        extra parenthesis are placed around the field format string.
        The isRepeating state need not be set for non-binary fields.

@item     void setDataStructCode( data_struct_code )

        Set the data structure code.
 

@item     void setDataTypeCode( data_type_code )

        Set the data type code.
 

@item     void setTag( string const & )

        Set the field tag.

@item     void setName( string const& )

        Set the field name.


@item     void setFieldTerm( char )

        Set the printable field terminator character.


@item     void setUnitTerm( char )
        Set the printable unit terminator character


@item     void setIsRepeating( bool repeating )

        Indicate that the field is repeating.  Again note that this is
        only necessary for binary repeating fields.

@end ftable



@node sio_8211SubfieldFormat, Repeating fields, sio_8211FieldFormat, Writers
@comment  node-name,  next,  previous,  up
@subsubsection sio_8211SubfieldFormat
    
This class contains specific subfield formatting information.

This class defines the following enumerators:
    
@code{
     typedef enum @{ A, I, R, S, C, B, X @} type;
    
     typedef enum @{ fixed, variable @} format;
}
    
This class declares the following members:
 
@ftable @code

@item     sio_8211SubfieldFormat()
    
@item     sio_8211SubfieldFormat( sio_8211SubfieldFormat const & )
    
@item     ~sio_8211SubfieldFormat()
    
@item     sio_8211SubfieldFormat& operator=( sio_8211SubfieldFormat const & )
    
@item     string const& getLabel() const
    
@item     type getType() const
    
@item     format getFormat() const
    
@item     int getLength() const 
    
@item     char getDelimiter() const
    
@item     sio_8211Converter const * getConverter() const
    
@item     void setLabel( string const & )
    
@item     void setType( type )
    
@item     void setFormat( format )
    
@item     void setLength( int ) 

        sets format to fixed as a side-effect

@item     void setDelimiter( char ) 

        sets format to variable as a side-effect

@item     void setConverter( sio_8211Converter const * )

@end ftable




@node Repeating fields, A note about repeating binary fields, sio_8211SubfieldFormat, Writers
@comment  node-name,  next,  previous,  up    
@subsubsection Repeating fields

SDTS Part 3 section 6.4.1 describes using repeating fields as a way of
saving space in module files.  It works by having multiple field
instances stored in the same record.  This saves the space that would
be required by having a DR for each of these fields; the space savings
is derived from not writing out a leader and directory for each of
those records.

SDTS++ supports repeating fields.  To use repeating fields, just do
the following:

@enumerate
@item 
Set the @code{sio_8211FieldFormat} data structure code to an array

@item
 Place multiple instances of the field that corresponds to the
@code{sio_8211FieldFormat} into the sc_Record to be passed to
@code{sio_8211Writer::put()}.  The writer will automatically detect the
multiple fields and put them in the same record, updating the DR's
directory entries appropriately.
    
@end enumerate

Here's an example of setting up a schema for a repeating spatial
address field:

@example
@code{
       // you can also use sio_ConverterFactory to return one for you instead
       sio_8211Converter_I converter_I; // integer converter

       sio_8211Schema schema;

       schema.push_back( sio_8211FieldFormat() );

       sio_8211FieldFormat&  field_format = schema.back();

       field_format.setDataStructCode( sio_8211FieldFormat::array );
       field_format.setDataTypeCode( sio_8211FieldFormat::implict_point );
       field_format.setName( "SPATIAL ADDRESS" );
       field_format.setTag( "SADR" );

       field_format.push_back( sio_8211SubfieldFormat() );

       field_format.back().setLabel( "X" );
       field_format.back().setType( sio_8211SubfieldFormat::I );
       field_format.back().setConverter( &converter_I );

       field_format.push_back( sio_8211SubfieldFormat() );

       field_format.back().setLabel( "Y" );
       field_format.back().setType( sio_8211SubfieldFormat::I );
       field_format.back().setConverter( &converter_I );
}
@end example




@node A note about repeating binary fields, Support for permuted tags, Repeating fields, Writers
@comment  node-name,  next,  previous,  up    
@subsubsection A note about repeating binary fields

Unfortunately the above mechanism breaks down in the case of
binary repeating fields thanks to an inherent ISO 8211 limitation.
The nature of this problem and its workaround are detailed in this
section.

The left-most parenthesis of an ISO 8211 subfield format string cannot
be next to a repeating binary format.  So this is illegal:

@example
        (B(32))
@end example

        (But, this is legal in the non-repeating case.)

The kludge as specified by the standard is to add another set of outer
parenthesis, like this:

@example
        ((B(32)))
@end example

What's even worse, the Topological Vector Profile (TVP) allows for
variants of the above:


@example
        ((2B(32)))
@end example
[This specifies a variable field that comes in two 32-bit chunks.]


@example
        (10(2B(32)))
@end example

[This specifies ten subfields of two 32-bit chunks.]

The DDR creation mechanism is pretty intelligent about generating the
field format strings.  It will count up like subfields (i.e., those
with identical types) and emit appropriate format text.  So, four
string subfields will generate "4A", which will be spliced
appropriately in the final format string.  Sadly, this general format
string making mechanism has difficulty generating proper repeating
binary format strings.

For example, consider a binary chunk (type '5' in 8211-speak) that has
two subfields 32 bits each.  With the default format string creating
mechanism, the format string would be "(2B(32))".  This doesn't have
the necessary extra outer parenthesis.  It _should_ be "((2B(32)))".

The fix for this was to check a few things after creating a complete
format string.  If the field format type was "binary string" and a
special "isRepeating" flag set, then the writer would know it had a
repeating binary field.  It'd then add the required extra set of
parenthesis.

That resolves repeating binary fields of the type "((nB(s)))".  's' is
the size, and that's given in the subfield type.  'n' are the number
of binary subfields, and we can easily count those.

Unfortunately, this only handles _variable_ length repeating binary
fields.  This mechanism does not handle the case of "(m(nB(s)))" where
'm' is the number of times the whole shebang is repeated.

So we had to _assume_ that most uses of binary repeating fields will
be variable.  SDTS++ does not accomodate binary fields of the type
"(m(nB(s)))".

The following source takes the above SADR example and changes it to
use binary repeating fields:

@example
       // you can also use sio_ConverterFactory to return one for you
       // instead as shown in the section on sio_Reader
       
       sio_8211Converter_BI32 converter_BI32; // 32 bit integer converter

       sio_8211Schema schema;

       schema.push_back( sio_8211FieldFormat() );

       sio_8211FieldFormat&  field_format = schema.back();

       field_format.setDataStructCode( sio_8211FieldFormat::array );
       field_format.setDataTypeCode( sio_8211FieldFormat::bit_string );
       field_format.setName( "SPATIAL ADDRESS" );
       field_format.setTag( "SADR" );
       field_format.setIsRepeating( true ); // hint to writer to add
                                            // extra parenthesis for
                                            // binary repeating field --
                                            // note that this isn't
                                            // necessary for any other type
                                            // of repeating field

       field_format.push_back( sio_8211SubfieldFormat() );

       field_format.back().setLabel( "X" );
       field_format.back().setType( sio_8211SubfieldFormat::B );
       field_format.back().setLength( 32 );
       field_format.back().setConverter( &converter_BI32 );

       field_format.push_back( sio_8211SubfieldFormat() );

       field_format.back().setLabel( "Y" );
       field_format.back().setType( sio_8211SubfieldFormat::B );
       field_format.back().setLength( 32 );
       field_format.back().setConverter( &converter_BI32 );
@end example


See also "sio_Writer_t"/main.cpp"`s build_binary_schema() for an example.

@node Support for permuted tags, Dropped leaders and directories, A note about repeating binary fields, Writers
@comment  node-name,  next,  previous,  up
@subsubsection Support for permuted tags
    
All ISO 8211 field tags correspond to SDTS field mnemonics with one
notable exception.  It is possible for there to be multiple instances
of an SDTS field that have different structures.  In that case, there
will be a DDR field entry for each of these fields.  The problem is
that they will have the _same_ tag.  Which means that finding the
correct tag to properly decode a field becomes difficult because there
is more than one tag to choose from.

The work-around the standard provides is to "permute" the field tags
by adding a single character.  Unfortunately this means that _all_
field tags have to have extra chracters so appended since ISO 8211
requires that all field tags be the same size.

[see section 6.1.2 in SDTS part 3]

SDTS++ does not have an automatic mechanism for dealing with tag
permutation.  That is, a writer will not scan a given schema and
permute tags when it notices that there is more than one field with
the same mnemonic, but with different structures.  This means that the
onus is entirely on the programmer to watch for and handle tag
permutation.

How to handle this?  It's easy but tedious.  First, each
sio_8211FieldFormat in the schema needs to have an extra, arbitrary
character added before handing that schema to the writer.  Second, use
field mnemonics with this extra character for each sc_Field you add to
the @code{sc_Record} given to the writer's @code{put()} call.  The
permuted tags will get written to the file like normal tags.




@node Dropped leaders and directories, Writer Example, Support for permuted tags, Writers
@comment  node-name,  next,  previous,  up
@subsubsection Dropped leaders and directories

ISO 8211 has another space saving feature.  DR leaders and directories
can be dropped if they don't change from DR to DR -- the last leader
and directory will be used for all DR's.  [c.f., section 5.2.1.2 in
the 1993 ISO 8211 spec.]

The @code{sio_8211Writer} has a member function,
@code{reuseLeaderAndDirectory()}, that's used to tell it that the next
record will be the last one to have a leader and directory.  (And the
leader identifier field will have 'R' instead of 'D' to indicate that
dropped leaders and directories are in effect.)  All subsequent records
given to its put() function will be emitted without leaders and
directories.

Please note that this obviously assumes that the record structures @emph{DO
NOT CHANGE}.  If they do, then the generated SDTS module file will
almost certainly be wrong.



@node Writer Example,  , Dropped leaders and directories, Writers
@comment  node-name,  next,  previous,  up
@subsubsection Example

See @file{tests/sio_Writer.cpp}" for example code.


@c ===========================================================================
@node Builder Classes, Logical Classes, I/O Classes, Using
@comment  node-name,  next,  previous,  up
@section Builder Classes

Manually grinding through SDTS records for both reading and reading
can be tedious.  The onus is on the programmer to iterate module
records, pulling out field and subfield values.  Moreover, the
programmer has to know in which modules to look for binary converter
information, and when.  The builder classes offer some convenience in
record translation both to and from SDTS modules, and in providing
utilities for easily getting binary converter information.

@menu
* Builder SDTS Module Classes::  SDTS module specific classes
* Binary Converter Builder::     Determine dataset binary converters
* sb_Directory::                 Finding modules easily through CATD
* sb_Accessor::                  Quickly finding and reading modules
@end menu


@c ===========================================================================
@node Builder SDTS Module Classes, Binary Converter Builder, Builder Classes, Builder Classes
@comment  node-name,  next,  previous,  up
@subsection Builder SDTS Module Classes

For each SDTS module, with few exceptions, there exists a
corresponding class found in @file{sdts++/builder/} .  Each of these
builder module classes inherits from @code{sb_Module}, and so provide
these methods:

@vtable @code
@item void getMnemonic( string & mnemonic )
Return the module's mnemonic

@item int getID() const
Return the record ID for the current record

@item void setID( int )
Set the record ID for the current record

@item bool getSchema( sio_8211Schema & schema )
Returns the schema for the current module; this is useful for
providing a @code{sio_8211Schema} to a @code{sio_Writer}.

@item bool getRecord( sc_Record & record )
Set @var{record} from the current builder module object.

@item bool setRecord( sc_Record const & record )
Populate the builder module object based on the fields and subfield
values in @var{record}.  Return false if the record fields don't
contain proper data associated with that specific builder module;
e.g., trying to set an IDEN builder module from an sc_Record with CATD
field and subfield values.

@item emitRecIdenField( bool )
Indicate whether the builder module should create ISO 8211 records
with the optional ISO 8211 record identifier field.  Note, setting
this field is optional, and actually contains redundant information.
Therefore it's not recommended to emit ISO 8211 record identifier
fields when creating SDTS modules.

@end vtable

Additionally, each builder class has three sets of methods, one for
setting module specific field/subfield values, one for getting same,
and the third for ``unsetting'' values.  Moreover, each of those
methods, in turn, have long name and mnemonic versions.

For example, the following two functions are equivalent members of @code{sb_Ldef}:

@table @code
@item bool sb_Ldef::getLayerLabel( string & ) const;
@item bool sb_Ldef::getLLBL( string & ) const;
@end table

@sp 2
They have semantic inverses of:

@table @code
@item bool setLayerLabel( std::string const& val );
@item bool setLLBL( std::string const& val );
@end table

@sp 2
There is also a third set:

@table @code
@item void unDefineLayerLabel( );
@item void unDefineLLBL( );
@end table

@sp 2
These last set of functions set the corresponding sc_Subfield to
``undefined''.  (That is, a NULL, or empty, value.)


Examples of use can be found in @file{tests/sb*t.cpp}.


@c ===========================================================================
@node Binary Converter Builder, sb_Directory, Builder SDTS Module Classes, Builder Classes
@comment  node-name,  next,  previous,  up
@subsection Binary Converter Builder

There exists in @file{sdts++/builder/sb_Utils.h}:

@defmethod sb_Utils addConverters catd-fn converters

Takes a string @var{catd-fn} that contains an SDTS CATD module
filename, and @var{converters} which is a binary converter table, and
does all the necessary module look-ups to populate the binary
converters.  This includes looking up coordinate binary types in the
IREF and DDSH modules found via the given CATD module.  Returns true
if successfully populated the binary converts, false otherwise.

@end defmethod

An example of use can be found in @file{tests/sb_Directory_t.cpp}.


@c ===========================================================================
@node sb_Directory,  sb_Accessor, Binary Converter Builder, Builder Classes
@comment  node-name,  next,  previous,  up
@subsection sb_Directory

@code{sb_Directory}, found in @file{sdts++/builder/sb_Catd.h},
provides a mechanism for looking up SDTS CATD module information.

@vtable @code
@item sb_Directory::sb_Directory()
@item sb_Directory::sb_Directory( string const & catd_filename )
Creates @code{sb_Directory} class; optional @var{catd_filename} specifies location of SDTS catalog module.

@item bool sb_Directory::find( string const & module_name, sb_Catd & module info )
Looks for @var{module_name} in currently loaded CATD.  If found, sets
the given @code{sb_Catd} record to values for that module, and returns
true; otherwise, it returns false.  The @code{sb_Catd} object can be
used to query the file name of the given module.

@item bool sb_Directory::catdFilename( string const & filename )
Tells the @code{sb_Directory} object to load up the CATD module found
at @var{filename} in preparation for @code{find()} calls.

@end vtable


@c ===========================================================================
@node sb_Accessor,  , sb_Directory, Builder Classes
@comment  node-name,  next,  previous,  up
@subsection sb_Accessor

@code{sb_Accessor}, which is found in
@file{sdts++/builder/sb_Accessor.h}, is a convenience class for
accessing arbitrary SDTS modules and records without having to open up
each module by hand.  The CATD module is used to find a dataset's
modules.

@vtable @code
@item sb_Accessor()
@item sb_Accessor( string const & catd_fn )
Create an @code{sb_Accessor}, optionally with @var{catd_fn} that
specifies the file name of a CATD module.

@item bool sb_Accessor::readCatd( string const & catd_fn )
Open and read the given CATD module specified in the @var{catd_fn};
return true if successfully read, otherwise false.

@item string & sb_Accessor::fileName() const;
Return the current CATD module file name.

@item bool sb_Accesssor::get( sb_Module & module, sio_8211_converter_dictionary* cv = 0x0 );
Use the CATD information to find the corresponding @var{module} file,
open it, read in the first record, and then use that record to
populate the given module.  This will return false if there are no
more records, the SDTS module file didn't exist, or there were some
I/O or resource problems.  (E.g., out of memory or a corrupted
module.)  Will return true if the module was successfully populated.
This can be invoked multiple times for modules with more than one
record; again get() will return false if all the module records have
been read. The optional converter parameter is used to provide
appropriate hints for reading binary data.


@end vtable

Note that this currently only handles single instances of a given
module type since the internal @code{sb_Accessor} state tracks
uniquely by module type.  (E.g., there are generally more than one
instance of spatial modules, such as line, node, and polygon modules.)
So, this would be chiefly used as a convenience for trivially accessing
non-spatial and attribute modules.

An example of use can be found in @file{tests/sb_accessor_t.cpp}.


@c ===========================================================================
@node Logical Classes,  , Builder Classes, Using
@comment  node-name,  next,  previous,  up
@section Logical Classes

These provide basic spatial primitive classes corresponding to the
SDTS logical spatial model specification, and are found in @file{sdts++/logical}.

@table @file
@item sl_Object.h
SDTS logical abstract base class

@item sl_Point.h
SDTS points

@item sl_Node.h
SDTS nodes

@item sl_Chain.h
SDTS chains

@item sl_String.h
SDTS strings

@item sl_Ring.h
SDTS rings

@item sl_Polygon.h
SDTS polygons

@end table


@c ===========================================================================
@node Credits, Legalese, Using, Top
@comment  node-name,  next,  previous,  up
@chapter Credits

SDTS++ was developed at the United States Geological Survey's
Mid-Continent Mapping Center's Software Engineering Section in Rolla,
Missouri.

@table @i
@item Principal Architects:   
Jamie Moyers (USGS) and Mark Coletti (SAIC)

@item Lead Programmers:       
Jamie Moyers (USGS) and Mark Coletti (SAIC)

@item Programming:            
Dave Edwards (SAIC), Justin Ferguson (USGS), Chad Slaughter (USGS),
James Morgan (SAIC), Shonie Maxwell (USGS)

@item Documentation:          
Mark Coletti (SAIC), James Morgan (SAIC), Shonie Maxwell (USGS)

@item Special Thanks To:      
Dr. Rong Li (Keane Federal Systems), Greg Martin (USGS), Mike Childs
(USGS), Paul Gray (USGS), Andrew Arensburger (UMD), David Hensinger
(Sandia National Labs), Steven Zhou, Bob Weber, Tim Fitzgerald, Frank
Warmerdam, David Weller, Alexander Gavrilov @email{angavrilov@@home.com},
Vandam @email{vandam@@ispc1.auto.inha.ac.kr}, 
Michal Kracik @email{kracik@@mbox.dkm.cz}, 
Daniel S Custer @email{dscuster@@usgs.gov}, Todd Sprague @email{todd@@pcavionics.com}


@item  Running Interference:   
Phyllis Altheide (USGS), Larry Moore (USGS)
@end table


@c ===========================================================================
@node Legalese, Support, Credits, Top
@comment  node-name,  next,  previous,  up
@chapter Legalese

The SDTS++ toolkit was written by employees and contractors of the
U.S. Geological Survey.  The USGS writes software to support
government research and data production operations, not to provide
free alternatives to commercial software.  The SDTS++ toolkit is
placed in the public domain in the spirit of sharing the results of
scientific research. The library is not an official USGS product, is
not commercial-grade software, is not guaranteed to be appropriate for
all SDTS applications, and is not supported.  We invite user comments
and suggestions, and will act on them as resources and as other
priorities permit.  However, the availability of this software does
not imply any USGS committment to fix reported bugs, provide
documentation, or assist other organizations in learning to use the
toolkit.

Neither the U.S. Government nor any agency thereof nor any of their
employees make any warranty, expressed or implied, or assume any legal
responsibility for the accuracy, completeness, or usefulness of any
information, apparatus, product, or process disclosed herein or
represent that its use would not infringe privately owned
rights. Reference to any specific commercial product, process, or
service by trade name, trademark, manufacturer, or otherwise does not
necessarily constitute or imply its endorsement, recommendation, or
favoring by the U.S. Government or any agency thereof.



@c ===========================================================================
@node Support, Bibliography, Legalese, Top
@comment  node-name,  next,  previous,  up
@chapter Support

@cindex support
@cindex mailing list

There is no technical support for SDTS++.  However, there is a mailing
list for SDTS related software.  One purpose of this list is to
provide peer support for SDTS software development efforts.  Some of
the SDTS++ development team subscribe to this list and _may_ address
problems related to the toolkit.  After all, if you're having problems
with the library, chances are they are having the same problems, too.

You can subscribe to this list by sending e-mail to
@email{majordomo@@mailrmon1.er.usgs.gov} with this line in the body of the
message:

subscribe sdts_software @email{myname@@my.host}


Substitute your e-mail address for @email{myname@@my.host}.  So I'd put in:



subscribe sdts_software @email{mcoletti@@lychnobite.org}



... if I wanted to subscribe to the mailing list.  DO NOT USE @email{myhname@@my.host}.

"sdts_software" is a technical discussion list.  There is no guarantee
that questions posted to this list will be answered.  General
information about SDTS should be requested by sending mail to
@email{sdts@@usgs.gov}.  @email{sdts@@usgs.gov} is also a public mailing
list, but it is monitored by USGS personnel.  Questions sent to it will
receive a response.

@c ===========================================================================
@node Bibliography, Concept Index, Support, Top
@comment  node-name,  next,  previous,  up
@chapter Bibliography

FIPS-173, Spatial Data Transfer Standard, ANSI.

ISO 8211:1994(E), ISO/IEC, Geneva, Switzerland.

STL Tutorial and Reference Guide, Musser & Saini, Addison-Wesley, 1996.



@node    Concept Index,  , Bibliography, Top
@c        node-name,    next, previous,        up
@unnumbered Concept Index
     
@printindex cp
     
@contents
@bye
